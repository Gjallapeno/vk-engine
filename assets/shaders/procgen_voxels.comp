#version 460
layout (local_size_x=8, local_size_y=8, local_size_z=8) in;

// Storage buffers for occupancy and material bitfields
layout (binding=0, std430) buffer Occ { uint occ[]; };
layout (binding=1, std430) buffer Mat { uvec2 mat[]; };

// Modes for P.mode
const int MODE_CLEAR       = 0;
const int MODE_FILL_BOX    = 1;
const int MODE_FILL_SPHERE = 2;
const int MODE_NOISE       = 3;
const int MODE_TERRAIN     = 4;

// Ops for P.op
const int OP_REPLACE     = 0;
const int OP_UNION       = 1;
const int OP_INTERSECT   = 2;
const int OP_SUBTRACT    = 3;

layout (std140, binding=2) uniform VoxParams {
    ivec3 dim;   int frame;
    vec3  volMin; float pad0;
    vec3  volMax; float pad1;
    // shape params
    vec3 boxCenter; float pad2;
    vec3 boxHalf;   float pad3;
    vec3 sphereCenter; float sphereRadius;
    int mode; int op; int noiseSeed; int material;
    ivec3 regionMin; int pad5;
    ivec3 regionMax; float terrainFreq;
} P;

float hash(vec3 p, float seed){
    return fract(sin(dot(p, vec3(12.9898,78.233,37.719)) + seed) * 43758.5453);
}

float hash(vec2 p, float seed){ return hash(vec3(p,0.0), seed); }

float noise(vec2 p, float seed){
    vec2 i = floor(p);
    vec2 f = fract(p);
    float a = hash(i, seed);
    float b = hash(i + vec2(1,0), seed);
    float c = hash(i + vec2(0,1), seed);
    float d = hash(i + vec2(1,1), seed);
    vec2 u = f*f*(3.0-2.0*f);
    return mix(mix(a,b,u.x), mix(c,d,u.x), u.y);
}

float fbm(vec2 p){
    float v = 0.0;
    float a = 0.5;
    for(int i=0;i<4;i++){
        v += noise(p, float(P.noiseSeed)+float(i)) * a;
        p *= 2.0; a *= 0.5;
    }
    return v;
}

uint part1by2(uint x){
    x &= 0x000003ffu;
    x = (x | (x << 16)) & 0x30000ffu;
    x = (x | (x << 8)) & 0x300f00fu;
    x = (x | (x << 4)) & 0x30c30c3u;
    x = (x | (x << 2)) & 0x9249249u;
    return x;
}

uint morton3D(uvec3 v){
    return part1by2(v.x) | (part1by2(v.y) << 1) | (part1by2(v.z) << 2);
}

void main(){
    ivec3 p = ivec3(gl_GlobalInvocationID.xyz) + P.regionMin;
    if (any(greaterThanEqual(p, P.regionMax))) return;

    uint shape = 0u;
    uint shapeMat = uint(P.material);
    vec3 pf = vec3(p) + 0.5;

    if(P.mode == MODE_FILL_BOX || P.mode == MODE_CLEAR ||
       P.mode == MODE_FILL_SPHERE || P.mode == MODE_NOISE){
        // compute shape occupancy
        if(P.mode == MODE_FILL_BOX){
            bvec3 inA = greaterThanEqual(pf, P.boxCenter - P.boxHalf);
            bvec3 inB = lessThanEqual   (pf, P.boxCenter + P.boxHalf);
            if(all(inA) && all(inB)) shape = 1u;
        }else if(P.mode == MODE_FILL_SPHERE){
            float d2 = dot(pf - P.sphereCenter, pf - P.sphereCenter);
            if(d2 <= P.sphereRadius * P.sphereRadius) shape = 1u;
        }else if(P.mode == MODE_NOISE){
            float n = hash(pf*0.08, float(P.noiseSeed));
            if(n < 0.5) shape = 1u; else shape = 0u;
        }
    }else if(P.mode == MODE_TERRAIN){
        float h = fbm(pf.xz * P.terrainFreq) * 20.0 + 20.0;
        if(pf.y < h){ shape = 1u; shapeMat = 1u; }

        // Scatter additional features based on 16x16 cells in the XZ plane.
        vec2 cell2 = floor(pf.xz / 16.0);
        float tn = hash(cell2, float(P.noiseSeed));
        if(tn > 0.85){
            // Simple foliage clumps
            vec2 center2 = cell2 * 16.0 + 8.0;
            float th = fbm(center2 * P.terrainFreq) * 20.0 + 20.0;
            vec3 tc = vec3(center2.x, th + 6.0, center2.y);
            if(distance(pf, tc) < 3.0){ shape = 1u; shapeMat = 2u; }
        }else if(tn > 0.75){
            // Rock outcrops
            vec2 center2 = cell2 * 16.0 + 8.0;
            float th = fbm(center2 * P.terrainFreq) * 20.0 + 20.0;
            vec3 rc = vec3(center2.x, th + 2.0, center2.y);
            if(distance(pf, rc) < 2.0){ shape = 1u; shapeMat = 3u; }
        }
    }

    uint morton = morton3D(uvec3(p));
    uint word = morton >> 5;
    uint bit = morton & 31u;
    uint prev = (occ[word] >> bit) & 1u;
    uint shift = (morton & 31u) * 2u;
    uvec2 mword = mat[word];
    uint prevMat = shift < 32u ? (mword.x >> shift) & 3u : (mword.y >> (shift - 32u)) & 3u;
    uint v = prev;
    uint matv = prevMat;
    if(P.mode == MODE_CLEAR){
        v = 0u; matv = 0u;
    }else{
        if(P.op == OP_REPLACE){
            v = shape;
            matv = shape > 0u ? shapeMat : 0u;
        }else if(P.op == OP_UNION){
            if(shape > 0u){ v = 1u; matv = shapeMat; }
            else { v = prev; matv = prevMat; }
        }else if(P.op == OP_INTERSECT){
            if(prev > 0u && shape > 0u){ v = 1u; matv = prevMat; }
            else { v = 0u; matv = 0u; }
        }else if(P.op == OP_SUBTRACT){
            if(shape > 0u){ v = 0u; matv = 0u; }
            else { v = prev; matv = prevMat; }
        }
    }
    if(v != prev){
        uint mask = 1u << bit;
        if(v == 1u) atomicOr(occ[word], mask);
        else atomicAnd(occ[word], ~mask);
    }
    if(matv != prevMat){
        if(shift < 32u){
            uint mask = 0x3u << shift;
            atomicAnd(mat[word].x, ~mask);
            atomicOr(mat[word].x, (matv & 0x3u) << shift);
        }else{
            uint s = shift - 32u;
            uint mask = 0x3u << s;
            atomicAnd(mat[word].y, ~mask);
            atomicOr(mat[word].y, (matv & 0x3u) << s);
        }
    }
}
