#version 460
layout (local_size_x=8, local_size_y=8, local_size_z=8) in;

// Storage images for occupancy and material IDs
layout (r8ui, binding=0) uniform uimage3D occOut;
layout (r8ui, binding=1) uniform uimage3D matOut;

// Modes for P.mode
const int MODE_CLEAR       = 0;
const int MODE_FILL_BOX    = 1;
const int MODE_FILL_SPHERE = 2;
const int MODE_NOISE       = 3;
const int MODE_TERRAIN     = 4;

// Ops for P.op
const int OP_REPLACE     = 0;
const int OP_UNION       = 1;
const int OP_INTERSECT   = 2;
const int OP_SUBTRACT    = 3;

layout (std140, binding=2) uniform VoxParams {
    ivec3 dim;   int frame;
    vec3  volMin; float pad0;
    vec3  volMax; float pad1;
    // shape params
    vec3 boxCenter; float pad2;
    vec3 boxHalf;   float pad3;
    vec3 sphereCenter; float sphereRadius;
    int mode; int op; int noiseSeed; int material;
    ivec3 regionMin; int pad5;
    ivec3 regionMax; float terrainFreq;
} P;

float hash(vec3 p, float seed){
    return fract(sin(dot(p, vec3(12.9898,78.233,37.719)) + seed) * 43758.5453);
}

float hash(vec2 p, float seed){ return hash(vec3(p,0.0), seed); }

float noise(vec2 p, float seed){
    vec2 i = floor(p);
    vec2 f = fract(p);
    float a = hash(i, seed);
    float b = hash(i + vec2(1,0), seed);
    float c = hash(i + vec2(0,1), seed);
    float d = hash(i + vec2(1,1), seed);
    vec2 u = f*f*(3.0-2.0*f);
    return mix(mix(a,b,u.x), mix(c,d,u.x), u.y);
}

float fbm(vec2 p){
    float v = 0.0;
    float a = 0.5;
    for(int i=0;i<4;i++){
        v += noise(p, float(P.noiseSeed)+float(i)) * a;
        p *= 2.0; a *= 0.5;
    }
    return v;
}

void main(){
    ivec3 p = ivec3(gl_GlobalInvocationID.xyz) + P.regionMin;
    if (any(greaterThanEqual(p, P.regionMax))) return;

    // Vulkan's texture coordinate system has (0,0,0) at the image's top-left
    // corner. Our world space assumes Y=0 at the bottom, so flip the Y axis
    // when accessing the storage images to keep terrain upright.
    ivec3 imgp = ivec3(p.x, P.dim.y - 1 - p.y, p.z);

    uint shape = 0u;
    uint shapeMat = uint(P.material);
    vec3 pf = vec3(p) + 0.5;

    if(P.mode == MODE_FILL_BOX || P.mode == MODE_CLEAR ||
       P.mode == MODE_FILL_SPHERE || P.mode == MODE_NOISE){
        // compute shape occupancy
        if(P.mode == MODE_FILL_BOX){
            bvec3 inA = greaterThanEqual(pf, P.boxCenter - P.boxHalf);
            bvec3 inB = lessThanEqual   (pf, P.boxCenter + P.boxHalf);
            if(all(inA) && all(inB)) shape = 1u;
        }else if(P.mode == MODE_FILL_SPHERE){
            float d2 = dot(pf - P.sphereCenter, pf - P.sphereCenter);
            if(d2 <= P.sphereRadius * P.sphereRadius) shape = 1u;
        }else if(P.mode == MODE_NOISE){
            float n = hash(pf*0.08, float(P.noiseSeed));
            if(n < 0.5) shape = 1u; else shape = 0u;
        }
    }else if(P.mode == MODE_TERRAIN){
        float h = fbm(pf.xz * P.terrainFreq) * 20.0 + 20.0;
        if(pf.y < h){ shape = 1u; shapeMat = 1u; }
        vec2 cell2 = floor(pf.xz / 16.0);
        float tn = hash(cell2, float(P.noiseSeed));
        if(tn > 0.85){
            vec2 center2 = cell2 * 16.0 + 8.0;
            float th = fbm(center2 * P.terrainFreq) * 20.0 + 20.0;
            vec3 tc = vec3(center2.x, th + 6.0, center2.y);
            if(distance(pf, tc) < 3.0){ shape = 1u; shapeMat = 2u; }
        }
    }

    uint prev = imageLoad(occOut, imgp).r;
    uint prevMat = imageLoad(matOut, imgp).r;
    uint v = prev;
    uint matv = prevMat;
    if(P.mode == MODE_CLEAR){
        v = 0u; matv = 0u;
    }else{
        if(P.op == OP_REPLACE){
            v = shape;
            matv = shape > 0u ? shapeMat : 0u;
        }else if(P.op == OP_UNION){
            if(shape > 0u){ v = 1u; matv = shapeMat; }
            else { v = prev; matv = prevMat; }
        }else if(P.op == OP_INTERSECT){
            if(prev > 0u && shape > 0u){ v = 1u; matv = prevMat; }
            else { v = 0u; matv = 0u; }
        }else if(P.op == OP_SUBTRACT){
            if(shape > 0u){ v = 0u; matv = 0u; }
            else { v = prev; matv = prevMat; }
        }
    }
    imageStore(occOut, imgp, uvec4(v,0,0,0));
    imageStore(matOut, imgp, uvec4(matv,0,0,0));
}
